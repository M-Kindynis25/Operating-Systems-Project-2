Στην παρούσα εργασία ανέπτυξα μια εφαρμογή στη γλώσσα προγραμματισμού C++, με στόχο τη λεξικογραφική ανάλυση ενός κειμένου και την εύρεση των top-k πιο συχνών λέξεων. Η εφαρμογή βασίζεται στην υλοποίηση μιας ιεραρχίας διεργασιών που περιλαμβάνει τρεις τύπους: τον root (lexan), τους splitters και τους builders.

Ο root αποτελεί τη βασική διεργασία που εκκινεί την εφαρμογή. Αρχικά, αναλύει τα ορίσματα γραμμής εντολών μέσω της συνάρτησης parseArguments, αποθηκεύοντας τις παραμέτρους σε μια δομή Parameters. Αυτές οι παράμετροι περιλαμβάνουν το αρχείο εισόδου, το αρχείο εξαιρέσεων, τον αριθμό των splitters και builders, την τιμή του k για τις top-k λέξεις και το αρχείο εξόδου. Στη συνέχεια, ο root δημιουργεί τα απαραίτητα named pipes για την επικοινωνία μεταξύ των διεργασιών. Τα splitters επικοινωνούν με τους builders μέσω των pipes fifo_splitterX_builderY, ενώ οι builders με τον root μέσω των fifo_builderY_laxen. Χρησιμοποίησα τη mkfifo για τη δημιουργία των named pipes και αποθήκευσα τα ονόματά τους σε vectors για εύκολη πρόσβαση.

Για την εκκίνηση των builders, ο root χρησιμοποιεί τη fork για να δημιουργήσει νέες διεργασίες. Σε κάθε child process, εκτελείται το εκτελέσιμο builder με τα κατάλληλα ορίσματα μέσω της execl. Επιπλέον, δημιούργησα pipes για την επικοινωνία του root με τους builders, ώστε να λαμβάνει μηνύματα ολοκλήρωσης μαζί με χρονικές μετρήσεις.

Στην κύρια λειτουργία του root, υπολόγισα τον συνολικό αριθμό γραμμών του αρχείου εισόδου με τη συνάρτηση countLines. Στη συνέχεια, διαμοίρασα τις γραμμές ισομερώς στους splitters, λαμβάνοντας υπόψη ότι ο τελευταίος splitter μπορεί να επεξεργαστεί περισσότερες γραμμές αν ο συνολικός αριθμός δεν διαιρείται ακριβώς. Οι splitters δημιουργούνται με παρόμοιο τρόπο όπως οι builders, χρησιμοποιώντας τη fork και την execl για την εκτέλεση του εκτελέσιμου splitter.

Οι splitters είναι διεργασίες που αναλαμβάνουν να διαβάσουν συγκεκριμένα τμήματα του αρχείου εισόδου. Κάθε splitter επεξεργάζεται ένα εύρος γραμμών, καθορισμένο από τις παραμέτρους startLine και endLine. Κατά την επεξεργασία, ο splitter διαβάζει το κείμενο γραμμή προς γραμμή και διαχωρίζει κάθε γραμμή σε λέξεις. Η συνάρτηση cleanWord παίζει καθοριστικό ρόλο σε αυτή τη διαδικασία.

Η συνάρτηση cleanWord λαμβάνει μια λέξη και την καθαρίζει από σημεία στίξης, σύμβολα και ψηφία, κρατώντας μόνο τους αλφαβητικούς χαρακτήρες. Επιπλέον, μετατρέπει όλους τους χαρακτήρες σε πεζά για ομοιομορφία. Μετά τον καθαρισμό, ελέγχει αν η λέξη είναι κενή ή αποτελείται από έναν μόνο χαρακτήρα. Σε αυτή την περίπτωση, η λέξη απορρίπτεται και δεν προωθείται περαιτέρω, καθώς θεωρείται ότι δεν προσφέρει σημαντική πληροφορία για την ανάλυση. Αυτό το φιλτράρισμα βοηθά στην απομάκρυνση ασήμαντων λέξεων ή συμβόλων που δεν συμβάλλουν ουσιαστικά στην ανάλυση συχνότητας.

Στη συνέχεια, η συνάρτηση ελέγχει αν η καθαρισμένη λέξη βρίσκεται στη λίστα εξαιρέσεων exclusionList. Αυτή η λίστα περιέχει κοινές λέξεις, όπως άρθρα, συνδέσμους και προθέσεις, που δεν θέλουμε να συμπεριληφθούν στην ανάλυση. Αν η λέξη υπάρχει στη λίστα εξαιρέσεων, απορρίπτεται και δεν προωθείται στους builders. Με αυτόν τον τρόπο, διασφαλίζεται ότι η ανάλυση επικεντρώνεται σε λέξεις που προσφέρουν ουσιαστική πληροφορία για το κείμενο.

Οι λέξεις που περνούν από τους παραπάνω ελέγχους αποστέλλονται στους builders μέσω των named pipes. Η κατανομή των λέξεων στους builders γίνεται με βάση μια συνάρτηση κατακερματισμού hashFunction, η οποία εξασφαλίζει ότι η ίδια λέξη θα αποσταλεί πάντα στον ίδιο builder, ανεξάρτητα από τον splitter που την επεξεργάστηκε. Αυτό επιτρέπει στους builders να συγκεντρώνουν και να μετρούν τις εμφανίσεις κάθε λέξης με συνέπεια.

Οι builders λαμβάνουν τις λέξεις από τους splitters και τις καταμετρούν. Χρησιμοποιούν έναν vector WordCount για να αποθηκεύουν κάθε μοναδική λέξη και τον αριθμό των εμφανίσεών της. Κάθε φορά που λαμβάνεται μια λέξη, η συνάρτηση processWord ελέγχει αν η λέξη υπάρχει ήδη στον vector. Αν υπάρχει, αυξάνει τον μετρητή της. Αν όχι, προσθέτει μια νέα εγγραφή με count ίσο με 1.

Μετά την ολοκλήρωση της λήψης και επεξεργασίας των λέξεων, οι builders ταξινομούν τον vector wordVector με βάση τη συχνότητα εμφάνισης των λέξεων σε φθίνουσα σειρά. Στη συνέχεια, αποστέλλουν τις top-k λέξεις τους στον root μέσω των named pipes fifo_builderY_laxen. Επιπλέον, υπολογίζουν τον πραγματικό χρόνο και τον CPU χρόνο εκτέλεσής τους και στέλνουν στον root μέσω των pipes επικοινωνίας μαζί με το acceptBuffer.

Ο root λαμβάνει τα αποτελέσματα από όλους τους builders και συγκεντρώνει τις top-k λέξεις από ολόκληρο το κείμενο. Χρησιμοποιεί τη συνάρτηση vector_sort για να ταξινομήσει τις λέξεις με βάση τη συνολική τους συχνότητα. Η παρουσίαση των αποτελεσμάτων γίνεται μέσω της συνάρτησης printResults, η οποία εκτυπώνει τις top-k λέξεις, τους χρόνους εκτέλεσης των splitters και builders, καθώς και τον αριθμό των σημάτων USR1 και USR2 που έλαβε.

Η συνάρτηση hashFunction διασφαλίζει ότι η κατανομή των λέξεων στους builders είναι ομοιόμορφη και ότι οι ίδιες λέξεις συγκεντρώνονται στον ίδιο builder. Αυτό είναι σημαντικό για την ακρίβεια της καταμέτρησης, καθώς αποφεύγεται η ανάγκη συγχώνευσης μετρήσεων από διαφορετικούς builders για την ίδια λέξη.

Τέλος, η εφαρμογή επιτυγχάνει τον στόχο της, παρέχοντας τις top-k πιο συχνές λέξεις του κειμένου, ενώ παράλληλα καταδεικνύει τις δυνατότητες της παράλληλης επεξεργασίας και της αποτελεσματικής διαχείρισης διεργασιών και επικοινωνίας στο λειτουργικό σύστημα. Η προσέγγιση αυτή μπορεί να επεκταθεί και να προσαρμοστεί σε μεγαλύτερα συστήματα ανάλυσης δεδομένων, όπου η αποδοτική κατανομή εργασιών και η παράλληλη επεξεργασία είναι απαραίτητες για την αντιμετώπιση μεγάλων όγκων πληροφορίας.
